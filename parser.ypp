%{
	#include <iostream>
	#include <string>
	#include <list>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"
	#include "Exceptions.h"
    #include "source.h"

    #define YYSTYPE NonTerminal
    extern list<string> varsListToTypesList(const list<Variable>& varList);

    extern int yylineno;
    int yylex();
    void yyerror(const char*);

    void myExit(){
        Framework::getInstance().exitOnError = true;
        exit(0);
    }

	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{
    public:
        RetType(const string& type) : NonTerminal("", type) {}

    };
    class Formals : public NonTerminal{
        public:
        list<Variable> namesAndTypes;
        Formals(list<Variable>& namesAndTypes) : NonTerminal("FORMALS", "FORMALS"), namesAndTypes(namesAndTypes) {
            this->namesAndTypes = namesAndTypes;
        }
    };
    class FormalsList : public NonTerminal{
        public:
            list<Variable> namesAndTypes;
            FormalsList(const string& name, const string& type) : NonTerminal("FORMALS LIST", "FORMALS LIST") {
                namesAndTypes.push_back(Variable(name, type));
            }

    };
	class FormalDecl : public NonTerminal{
	public:
	    FormalDecl(const string& name, const string& type) : NonTerminal(name, type) {this->name = name; this->type = type;}
	};
    class Statements : public NonTerminal{
    public:
        Statements(const string& type): NonTerminal("", type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): NonTerminal("", type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): NonTerminal("", type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{
	public:
	    Call(const string& name, const string& type) : NonTerminal(name, type){}

	};
	class ExpList : public NonTerminal{
	    public:
	    ExpList() : NonTerminal("", "")  {}
	};
    class Type : public NonTerminal{
        public:
        Type(const string& type) : NonTerminal("", type) {this->type = type;}
    };
    class Exp : public NonTerminal{
        public:
        Exp(const string& type) : NonTerminal("", type) {}
    };

    static string typeBinopAddChecking(string type1, string type2){
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        if(type1 == "BYTE" || type2 == "BYTE"){
            return "BYTE";
        }
        if(type1 == "SET" && type2 == "SET"){
            output::errorMismatch(yylineno);
            myExit();
        }
        return "SET";
    }

    string typeBinopMultiplicativeChecking(string type1, string type2){
        if(type1 == "SET" || type2 == "SET"){
            output::errorMismatch(yylineno);
            myExit();
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        return "BYTE";
    }

//
%}

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUALITY
%nonassoc RELOP_RELATIONAL
%left BINOP_ADDITIVE
%left BINOP_MULTIPLICATIVE
%right NOT
%left SC RPAREN RBRACE RBRACKET
%right LBRACE LPAREN LBRACKET

%right COMMA
%right WHILE
%right IF
%right ELSE
%nonassoc TRUE FALSE RETURN BREAK CONTINUE DOTS ID NUM STRING SET INT BYTE B BOOL VOID

%%


//TODO: ensure type safety on everything (a value can become it's own type.  A byte can become an int.) ("in" relop is used byte/int in set)
//DONE: errors
//DONE: print, printi
//DONE: complete Framework class
//DONE: Recursion problem - undefined at call time - verify that we pass (should pass already)
//TODO: enforce size limitations on set and byte (255)
//DONE: enforce existence of void main() function


Program:		Funcs {};
Funcs:			/*epsilon*/ {} //DONE: nothing
                    |FuncDecl Funcs {}; //DONE: nothing
FuncDecl:		RetType
                ID {
                    Framework::getInstance().addScope(Scope::FUNCTION);
                    Framework::getInstance().addFunction(Function(yylval.name,$1.type));
                }
                LPAREN
                Formals {
                    //add params
                    int numParamsAddedSoFar = 0;
                    for (const Variable& param : $5.namesAndTypes){
                        Framework::getInstance().addParamToLastFunc(param);

                        ++numParamsAddedSoFar;
                        Variable offsetFixedParam = Variable(param.name, param.type, -numParamsAddedSoFar);
                        Framework::getInstance().insertVariableIntoTopScope(offsetFixedParam);
                    }
                }
                RPAREN
                LBRACE
                Statements
                RBRACE {
                    Framework::getInstance().popScope();
                };
RetType:		Type {$$ = RetType($1.type);} // DONE: extract type from Type
                    | VOID {$$ = RetType("VOID");}; //DONE: RetType.type = "VOID"
Formals:		/*epsilon*/ {} //DONE: nothing
                    | FormalsList {
                        Formals formals = Formals($1.namesAndTypes);
                        $$ = formals;
                        $$.namesAndTypes = formals.namesAndTypes;
                        //cout << "\n\nFormalsReceived.namesAndTypes.size() = " << $$.namesAndTypes.size() << endl;
                    } ;
FormalsList:	FormalDecl {
                    FormalsList formalsList = FormalsList($1.name, $1.type);
                    $$ = formalsList;
                    $$.namesAndTypes = formalsList.namesAndTypes;
                    //cout << "\n\nReceived.namesAndTypes.size() = " << $$.namesAndTypes.size() << endl;
                }
                    | FormalDecl COMMA FormalsList{$$ = $3; $$.namesAndTypes.push_front(Variable($1.name, $1.type));} ; //DONE: extract name, type from FormalDecl and append to list of names, types extracted from FormalsList
FormalDecl:		Type ID {$$ = FormalDecl(yylval.name, $1.type);} ;
Statements:		Statement {$$ = Statements($1.type);} //Done
                    | Statements Statement{} ; //nothing
Statement:		LBRACE {Framework::getInstance().addScope(Scope::BLOCK);}
                Statements {Framework::getInstance().popScope();}
                RBRACE {}
                    | Type ID SC { Framework::getInstance().insertVariableIntoTopScope(Variable(yylval.name,$1.type));} // Done
                    | Type ID ASSIGN Exp SC { Framework::getInstance().insertVariableIntoTopScope(Variable(yylval.name,$1.type));} // Done
                    | ID ASSIGN Exp SC {} //nothing
                    | Call SC {} //nothing
                    | RETURN SC {$$ = Statement("VOID");} // Done
                    | RETURN Exp SC {$$ = Statement($2.type);} // Done
                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT {
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                    }
                    | IF
                    LPAREN
                    Exp
                    RPAREN marker_RPAREN
                    Statement marker_STATEMENT
                    ELSE {Framework::getInstance().addScope(Scope::IF);}
                    Statement {
                        Framework::getInstance().popScope();
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            myExit();
                        }
                    }
                    | WHILE LPAREN Exp RPAREN {Framework::getInstance().addScope(Scope::LOOP);} Statement {Framework::getInstance().popScope();} {
                    if ($3.type != "BOOL"){
                         output::errorMismatch(yylineno);
                         myExit();
                    }

                    }
                    | BREAK SC{
                        if(Framework::getInstance().getTopScope().getScopeType() != Scope::LOOP){
                             output::errorUnexpectedBreak(yylineno);
                             myExit();
                    }
                     }
                    | CONTINUE SC{
                        if(Framework::getInstance().getTopScope().getScopeType() != Scope::LOOP){
                            output::errorUnexpectedContinue(yylineno);
                            myExit();
                        }
                    }
Call:			ID //{$1.name = yylval.name;}
                LPAREN
                ExpList
                RPAREN {
                        try{
                            string type = Framework::getInstance()[$1.name].type; // check the syntax. need Framework::getInstance().symbol_table[$1.name] to be a "Function" struct

                            if(varsListToTypesList(dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters()) != $3.arrguments_list){
                                list<Variable> params = dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters();
                                const std::list<string> typesList = varsListToTypesList(params);
                                vector<string> argTypes = vector<string>(typesList.begin(), typesList.end());
                                output::errorPrototypeMismatch(yylineno, $1.name, argTypes);
                            }
                            $$ = Call ($1.name, type);
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            myExit();
                        }
                    }
                    | ID LPAREN RPAREN {

                        try{
                               string type = Framework::getInstance()[yylval.name].type;
                               $$ = Call (yylval.name, type);
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, yylval.name);
                            myExit();
                        }
                    }; //
ExpList:		Exp {   $$ = ExpList(); // making the one size list by adding the EXP type into the list
                        $$.arrguments_list.push_front($1.type);
                     } //
                    | Exp COMMA ExpList {
                        $$ = $3;
                        $$.arrguments_list.push_front($1.type);// adding into the list
                    }
Type:			INT {$$ = Type("INT");}
                    | BYTE{$$ =  Type("BYTE");}
                    | BOOL {$$ =  Type("BOOL");}
                    | SET LBRACKET NUM DOTS NUM RBRACKET {$$ = Type("SET");};
Exp:			LPAREN Exp RPAREN {$$ =  Exp($2.type);} //
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1.type, $3.type);
                        $$ = Exp(res_type);
                        } //
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1.type, $3.type);
                        $$ = Exp(res_type);
                    }
                    | ID {
                            try{
                                $$ =  Exp(Framework::getInstance()[yylval.name].type);
                            }
                            catch(Exceptions::IdentifierDoesNotExistException &e){
                                output::errorDef(yylineno, yylval.name);
                                myExit();
                            }


                    } //
                    | Call {$$ =  Exp($1.type);}
                    | NUM {$$ = Exp("INT");}
                    | NUM B {$$ =  Exp("BYTE");}
                    | STRING {$$ =  Exp("STRING");}
                    | TRUE {$$ =  Exp("BOOL");}
                    | FALSE {$$ =  Exp("BOOL");}
                    | NOT Exp {
                        if($2.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }
                    }
                    | Exp AND Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                       }
                       else{
                           $$ =  Exp("BOOL");
                       }
                    }
                    | Exp OR Exp{
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             myExit();
                       }
                       else{
                           $$ =  Exp("BOOL");
                       }
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($3.type != "INT" && $3.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             myExit();
                      }
                      else{
                          $$ =  Exp ("BOOL");
                      }
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                             output::errorMismatch(yylineno);
                             myExit();
                        }
                        else{
                            $$ =  Exp("INT");
                        }

                    };
marker_RPAREN:      /*epsilon*/ {Framework::getInstance().addScope(Scope::IF);}
marker_STATEMENT:   /*epsilon*/ {Framework::getInstance().popScope();}

%%
void yyerror(const char*){
	output::errorSyn(yylineno);
	myExit();
}

int main(){
    yyparse();
    if (!Framework::getInstance().mainExists) output::errorMainMissing();;
}