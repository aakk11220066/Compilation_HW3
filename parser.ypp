%{
	#include <iostream>
	#include <string>
	#include <stack>
	using namespace std;
	#include "Framework::getInstance().h"
	#include "Symbol.h"

	class NonTerminal{
	public:
	    const string name = "";
	    const string type = "";
	    stack<NonTerminal> namesAndTypes = stack<NonTerminal>();

	    NonTerminal(const string& name, const string& type){
	        this->name = name;
	        this->type = type;
	    }
	};

	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{};
    class Formals : public NonTerminal{};
    class FormalsList : public NonTerminal{
        FormalsList(const string& name, const string& type){
            namesAndTypes.push(NonTerminal(name, type));
        }
        FormalsList(const string& name, const string& type, const stack& namesAndTypes){
            this->namesAndTypes = namesAndTypes;
            this->namesAndTypes.push(NonTerminal(name, type));
        }
    };
	class FormalDecl : public NonTerminal{
	    FormalDecl(const string& name, const string& type) : name(name), type(type){}
	};
    class Statements : public NonTerminal{
        Statements(const string& type): type(type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): type(type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): type(type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{};
	class ExpList : public NonTerminal{
	    public:
	    List<string> arrguments_list;
	    ExpList(){
	        arrguments_list = new List<string>();
	    }
	};
    class Type : public NonTerminal{
        Type(cont string& type) : type(type);
    };
    class Exp : public NonTerminal{
        Exp(cont string& type) : type(type);
    };

    static string typeBinopChecking(Exp e1, Exp e2){
        if (e1.type == "INT" || e2.type == "INT"){
            return "INT";
        }
        if(e1.type == "BYTE" || e2.type == "BYTE"){
            return "BYTE";
        }
        if(e1.type == "SET" && e2.type == "SET"){
            return error;// TODO: check the error type
        }
        return "SET";
    }

    static string typeBinopMultiplicativeChecking(Exp e1, Exp e2){
            if(e1.type == "SET" || e2.type == "SET"){
                return error;// TODO: check the error type
            }
            if (e1.type == "INT" || e2.type == "INT"){
                return "INT";
            }
            return "BYTE";
        }


    //TODO: static function for the return issue
    extern int yylineno;
    extern YYSTYPE yylval;

    int yylex();
    void yyerror(const char*);
%}


%%


//TODO: ensure type safety on everything (a value can become it's own type.  A byte can become an int.) ("in" relop is used byte/int in set)
//TODO: errors
//TODO: print, printi
//TODO: complete Framework class
//TODO: Recursion problem - undefined at call time
//TODO: ask Piazza about if/else/while scope
//TODO: enforce size limitations on set and byte (255)
//TODO: enforce existence of void main() function


Program:		Funcs {output::printProductionRule(1);}; // TODO: add global scope to framework
Funcs:			/*epsilon*/ {} //DONE: nothing
                    |FuncDecl Funcs {}; //DONE: nothing
FuncDecl:		RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE{} ; // TODO: add Function to symbol table with name, type, list_of_params.  Also add parameters (=list of names, types) to symbol table + function scope
RetType:		Type {$$ = RetType($1.type);} // DONE: extract type from Type
                    | VOID {$$ = RetType($1.type);}; //DONE: RetType.type = "VOID"
Formals:		/*epsilon*/ {} //DONE: nothing
                    | FormalsList {$$ = Formals($1.namesAndTypes);} ; // DONE: extract names, types from FormalsList
FormalsList:	FormalDecl {$$ = FormalsList($1.name, $1.type);} // DONE: extract name, type from FormalDecl (create list of length 1)
                    | FormalDecl COMMA FormalsList{$$ = FormalsList($1.name, $1.type, $3.namesAndTypes);} ; //DONE: extract name, type from FormalDecl and append to list of names, types extracted from FormalsList
FormalDecl:		Type ID{FormalDecl($1.type, $2.name);} ;
Statements:		Statement {$$ = Statements($1.type)} //Done
                    | Statements Statement{} ; /nothing
Statement:		LBRACE Statements RBRACE {Framework::getInstance().addScope(Framework::getInstance().scopeType.BLOCK);} // Done
                    | Type ID SC {insertVariableIntoTopScope(Variable($2,$1.type));} // Done
                    | Type ID ASSIGN Exp SC {insertVariableIntoTopScope(Variable($2,$1.type));} // Done
                    | ID ASSIGN Exp SC {} //nothing
                    | Call SC {} //nothing
                    | RETURN SC {$$ = new Statement("VOID");} // Done
                    | RETURN Exp SC {$$ = Statement($2.type)} // Done
                    | IF LPAREN Exp RPAREN Statement{
                        if ($3.type == "BOOL"){
                            Framework::getInstance().addScope(Framework::getInstance().scopeType.IF);
                        }
                        else{
                             return error; // TODO: add the correct error code
                        }

                    }
                    | IF LPAREN Exp RPAREN Statement ELSE Statement {
                        if ($3.type == "BOOL"){
                            Framework::getInstance().addScope(Framework::getInstance().scopeType.IF);
                            Framework::getInstance().addScope(Framework::getInstance().scopeType.IF);
                        }
                        else{
                             return error; // TODO: add the correct error code
                        }

                    }
                    | WHILE LPAREN Exp RPAREN Statement{
                    if ($3.type == "BOOL"){
                        Framework::getInstance().addScope(Framework::getInstance().scopeType.LOOP);
                    }
                    else{
                        return error; // TODO: add the correct error code
                    }

                    }
                    | BREAK SC{
                        if(Framework::getInstance().scopes.getTopScope().getType() != scopeType.LOOP){
                             return errorUnexpectedBreak(lineno);
                    }
                     }  //TODO: need the functions in Framework: getTopScopes(), GetScopeType()
                    | CONTINUE SC{
                        if(Framework::getInstance().scopes.getTopScope().getScopeType() != scopeType.LOOP){
                            return errorUnexpectedBreak(lineno);}
                    }
Call:			ID LPAREN ExpList RPAREN {
                        if(!Framework::getInstance().contains($1.name)){
                            return errorUnderFunc(lineno,$1.name)
                        }
                        string type = Framework::getInstance().symbol_table[$1.name].type; // check the syntax. need Framework::getInstance().symbol_table[$1.name] to be a "Function" struct
                        if(!Framework::getInstance().symbol_table[$1.name].getList() == $3.getList()){
                            return errorPrototypeMismatch(lineno,$1.name,Framework::getInstance().symbol_table[$1.name].getParameters());
                        }
                        $$ = new Call ($1.name, type)
                        }
                    | ID LPAREN RPAREN {
                    if(!Framework::getInstance().contains($1.name)){
                       return errorUnderFunc(lineno,$1.name)
                       }
                       string type = Framework::getInstance().symbol_table[$1.name].type;
                       $$ = new Call ($1.name, type)
                    }; //
ExpList:		Exp {   $$ = new ExpList(); // making the one size list by adding the EXP type into the list
                        $$.addTypeToListArrguments($1.type);} //
                    | Exp COMMA ExpList { $$.addTypeToListArrguments($1.type)}; // adding into the list
Type:			INT {$$ = new Type("INT");}
                    | BYTE{$$ = new Type("BYTE");}
                    | BOOL {$$ = new Type("BOOL");}
                    | SET LBRACKET NUM DOTS NUM RBRACKET {$$ = new Type("SET");};
Exp:			LPAREN Exp RPAREN {$$ = new Exp($2.type);} //
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1,$2);
                        $$ = new Exp(res_type);
                        } //
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1,$2);
                        $$ = new Exp(res_type);
                    }
                    | ID {$$ = new Exp(Framework::getInstance().symbol_table[$1.name].type);} //
                    | Call {$$ = new Exp($1.type);}
                    | NUM {$$ = new Exp("INT")";}
                    | NUM B {$$ = new Exp("BYTE");}
                    | STRING {$$ = new Exp("STRING");}
                    | TRUE {$$ = new Exp("BOOL");}
                    | FALSE {$$ = new Exp("BOOL");}
                    | NOT Exp {
                        if($2.type != "BOOL"){
                            return error; // TODO: check the right error
                        }
                        else{
                            $$ = new Exp("BOOL");
                        }
                    }
                    | Exp AND Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                           return error; // TODO: check the right error
                       }
                       else{
                           $$ = new Exp("BOOL");
                       }
                    }
                    | Exp OR Exp{
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                           return error; // TODO: check the correct error
                       }
                       else{
                           $$ = new Exp("BOOL");
                       }
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                            return error; // TODO: check the correct error.
                        }
                        else{
                            $$ = new Exp ("BOOL");
                        }
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                          return error; // TODO: check the correct error
                      }
                      else{
                          $$ = new Exp ("BOOL");
                      }
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                            return error; // TODO: check the correct error
                        }
                        else{
                            $$ = new Exp("INT");
                        }

                    };

%%
void yyerror(const char*){
	output::errorSyn(yylineno);
}

int main(){
	 yyparse();
	

}