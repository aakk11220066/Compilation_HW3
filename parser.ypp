%{
	#include <iostream>
	#include <string>
	#include <stack>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"

	class NonTerminal{
	public:
	    const string name = "";
	    const string type = "";
	    stack<NonTerminal> namesAndTypes = stack<NonTerminal>();

	    NonTerminal(const string& name, const string& type){
	        this->name = name;
	        this->type = type;
	    }
	};

	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{};
    class Formals : public NonTerminal{};
    class FormalsList : public NonTerminal{
        FormalsList(const string& name, const string& type){
            namesAndTypes.push(NonTerminal(name, type));
        }
        FormalsList(const string& name, const string& type, const stack& namesAndTypes){
            this->namesAndTypes = namesAndTypes;
            this->namesAndTypes.push(NonTerminal(name, type));
        }
    };
	class FormalDecl : public NonTerminal{
	    FormalDecl(const string& name, const string& type) : name(name), type(type){}
	};
    class Statements : public NonTerminal{
        Statements(const string& type): type(type){}
    };
	class Statement : public NonTerminal{
	    Statement(const string& type): type(type){}
	};
	class Call : public NonTerminal{};
	class ExpList : public NonTerminal{};
    class Type : public NonTerminal{};
    class Exp : public NonTerminal{};

    //TODO: static function for the return issue
    extern int yylineno;
    extern YYSTYPE yylval;

    int yylex();
    void yyerror(const char*);
%}


%%


//TODO: ensure type safety on everything (a value can become it's own type.  A byte can become an int.) ("in" relop is used byte/int in set)
//TODO: errors
//TODO: print, printi
//TODO: complete Framework class
//TODO: Recursion problem - undefined at call time
//TODO: ask Piazza about if/else/while scope
//TODO: enforce size limitations on set and byte (255)
//TODO: enforce existence of void main() function


Program:		Funcs {output::printProductionRule(1);}; // TODO: add global scope to framework
Funcs:			/*epsilon*/ {} //DONE: nothing
                    |FuncDecl Funcs {}; //DONE: nothing
FuncDecl:		RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE{} ; // TODO: add function to symbol table with name, type.  Also add parameters (=list of names, types) to symbol table + function scope
RetType:		Type {$$ = RetType($1.type);} // DONE: extract type from Type
                    | VOID {$$ = RetType($1.type);}; //DONE: RetType.type = "VOID"
Formals:		/*epsilon*/ {} //DONE: nothing
                    | FormalsList {$$ = Formals($1.namesAndTypes);} ; // DONE: extract names, types from FormalsList
FormalsList:	FormalDecl {$$ = FormalsList($1.name, $1.type);} // DONE: extract name, type from FormalDecl (create list of length 1)
                    | FormalDecl COMMA FormalsList{$$ = FormalsList($1.name, $1.type, $3.namesAndTypes);} ; //DONE: extract name, type from FormalDecl and append to list of names, types extracted from FormalsList
FormalDecl:		Type ID{FormalDecl($1.type, $2);} ; // TODO: check -- construct Node with name, type
Statements:		Statement {$$ = Statements($1.type)} //Done
                    | Statements Statement{} ; /nothing
Statement:		LBRACE Statements RBRACE {Framework.addScope(Framework.scopeType.BLOCK);} // Done
                    | Type ID SC {insertVariableIntoTopScope(Variable($2,$1.type));} // Done
                    | Type ID ASSIGN Exp SC {insertVariableIntoTopScope(Variable($2,$1.type));} // Done
                    | ID ASSIGN Exp SC {} //nothing
                    | Call SC {} //nothing
                    | RETURN SC {$$ = Statement("VOID");} // Done
                    | RETURN Exp SC {$$ = Statement($2.type)} // Done
                    | IF LPAREN Exp RPAREN Statement{output::printProductionRule(21);} // TODO: add new scope to stack; ensure type safety
                    | IF LPAREN Exp RPAREN Statement ELSE Statement {output::printProductionRule(22);} // TODO: add 2 new scopes to stack consecutively; ensure type safety
                    | WHILE LPAREN Exp RPAREN Statement{output::printProductionRule(23);}  // TODO: add new scope to stack; ensure type safety
                    | BREAK SC{output::printProductionRule(24);}  // TODO: ensure that top scope on stack is loop-type
                    | CONTINUE SC{output::printProductionRule(25);} ; // TODO: ensure that top scope on stack is loop-type
Call:			ID LPAREN ExpList RPAREN {output::printProductionRule(26);} // TODO: extract name from ID, access symbol table to get type; Ensure type safety on ExpList (based on symbol table)
                    | ID LPAREN RPAREN {output::printProductionRule(27);}; // TODO: extract name from ID, access symbol table to get type
ExpList:		Exp {output::printProductionRule(28);} // TODO: extract type from Exp (create list of length 1)
                    | Exp COMMA ExpList {output::printProductionRule(29);}; //TODO: extract type from Exp and append to list of types extracted from ExpList
Type:			INT {output::printProductionRule(30);} // TODO: Construct Type with type=="INT"
                    | BYTE{output::printProductionRule(31);} // TODO: Construct Type with type=="BYTE"
                    | BOOL {output::printProductionRule(32);} // TODO: Construct Type with type=="BOOL"
                    | SET LBRACKET NUM DOTS NUM RBRACKET {output::printProductionRule(33);}; // TODO: Construct Type with type=="SET"
Exp:			LPAREN Exp RPAREN {output::printProductionRule(34);} // TODO: Construct Exp with type==exp.type
                    | Exp BINOP_ADDITIVE Exp {output::printProductionRule(35);} // TODO: Ensure that both exp.type=="INT" or exp.type=="BYTE" or exp.type=="SET" (but only a single param); Construct Exp with most inclusive type (=set, if set is one of the operands)
                    | Exp BINOP_MULTIPLICATIVE Exp {output::printProductionRule(35);} // TODO: Ensure that both exp.type=="INT" or exp.type=="BYTE" or exp.type=="SET" (but only a single param); Construct Exp with most inclusive type
                    | ID {output::printProductionRule(36);} // TODO: Construct Exp with type==symbol_table[name].type
                    | Call {output::printProductionRule(37);} // TODO: Construct Exp with type==Call.type
                    | NUM {output::printProductionRule(38);} // TODO: Construct Exp with type=="INT"
                    | NUM B {output::printProductionRule(39);} // TODO: Construct Exp with type=="BYTE"
                    | STRING {output::printProductionRule(40);} // TODO: Construct Exp with type=="STRING" (useful only for calling print function)
                    | TRUE {output::printProductionRule(41);} // TODO: Construct Exp with type=="BOOL"
                    | FALSE {output::printProductionRule(42);} // TODO: Construct Exp with type=="BOOL"
                    | NOT Exp {output::printProductionRule(43);} // TODO: Ensure that exp.type=="BOOL"; Construct Exp with type="BOOL"
                    | Exp AND Exp {output::printProductionRule(44);} // TODO: Ensure that both exp.type=="BOOL"; Construct Exp with type="BOOL"
                    | Exp OR Exp{output::printProductionRule(45);} // TODO: Ensure that both exp.type=="BOOL"; Construct Exp with type="BOOL"
                    | Exp RELOP_RELATIONAL Exp {output::printProductionRule(46);} // TODO: Ensure that both exp.type=="INT" or exp.type=="BYTE"; Construct Exp with type="BOOL"
                    | Exp RELOP_EQUALITY Exp {output::printProductionRule(46);} // TODO: Ensure that both exp.type is one of the following: NUM, NUM B, INT, BYTE; Construct Exp with type="BOOL"
                    | LPAREN Type RPAREN Exp {output::printProductionRule(47);}; //CASTING TODO: ensure that Type.type=="INT" and Exp.type=="SET"; Construct Exp with type="INT"

%%
void yyerror(const char*){
	output::errorSyn(yylineno);
}

int main(){
	 yyparse();
	

}