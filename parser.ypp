%{
	#include <iostream>
	#include <string>
	#include <list>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"
	#include "Exceptions.h"
    #include "source.h"

    #define YYSTYPE NonTerminal
    extern list<string> varsListToTypesList(const list<Variable>& varList);

    extern int yylineno;
    int yylex();
    void yyerror(const char*);



	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{
    public:
        RetType(const string& type) : NonTerminal("", type) {}

    };
    class Formals : public NonTerminal{
        public:
        list<Variable> namesAndTypes;
        Formals(list<Variable>& namesAndTypes) : NonTerminal("", ""), namesAndTypes(namesAndTypes) {}
    };
    class FormalsList : public NonTerminal{
        public:
            list<Variable> namesAndTypes;
            FormalsList(const string& name, const string& type) : NonTerminal("", "") {
                namesAndTypes.push_back(Variable(name, type));
            }

    };
	class FormalDecl : public NonTerminal{
	public:
	    FormalDecl(const string& name, const string& type) : NonTerminal(name, type) {}
	};
    class Statements : public NonTerminal{
    public:
        Statements(const string& type): NonTerminal("", type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): NonTerminal("", type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): NonTerminal("", type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{
	public:
	    Call(const string& name, const string& type) : NonTerminal(name, type){}

	};
	class ExpList : public NonTerminal{
	    public:
	    ExpList() : NonTerminal("", "")  {}
	};
    class Type : public NonTerminal{
        public:
        Type(const string& type) : NonTerminal("", type) {}
    };
    class Exp : public NonTerminal{
        public:
        Exp(const string& type) : NonTerminal("", type) {}
    };

    static string typeBinopAddChecking(string type1, string type2){
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        if(type1 == "BYTE" || type2 == "BYTE"){
            return "BYTE";
        }
        if(type1 == "SET" && type2 == "SET"){
            output::errorMismatch(yylineno);
            exit(0);
        }
        return "SET";
    }

    string typeBinopMultiplicativeChecking(string type1, string type2){
        if(type1 == "SET" || type2 == "SET"){
            output::errorMismatch(yylineno);
            exit(0);
        }
        if (type1 == "INT" || type2 == "INT"){
            return "INT";
        }
        return "BYTE";
    }

//
%}

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUALITY
%nonassoc RELOP_RELATIONAL
%left BINOP_ADDITIVE
%left BINOP_MULTIPLICATIVE
%right NOT
%left SC RPAREN RBRACE RBRACKET
%right LBRACE LPAREN LBRACKET

%right COMMA WHILE ELSE IF
%nonassoc TRUE FALSE RETURN BREAK CONTINUE DOTS ID NUM STRING SET INT BYTE B BOOL VOID

%%


//TODO: ensure type safety on everything (a value can become it's own type.  A byte can become an int.) ("in" relop is used byte/int in set)
//DONE: errors
//DONE: print, printi
//TODO: complete Framework class
//TODO: Recursion problem - undefined at call time
//TODO: enforce size limitations on set and byte (255)
//DONE: enforce existence of void main() function


Program:		Funcs {};
Funcs:			/*epsilon*/ {} //DONE: nothing
                    |FuncDecl Funcs {}; //DONE: nothing
FuncDecl:		RetType ID LPAREN Formals RPAREN LBRACE {Framework::getInstance().addScope(Scope::FUNCTION);
                                                            for (const Variable& var : $4.namesAndTypes){
                                                                Framework::getInstance().insertVariableIntoTopScope(var);
                                                            }
                                                        } Statements {Framework::getInstance().popScope();
                                                                     } RBRACE{
                    Framework::getInstance().addFunction(Function(yylval.name,$1.type, $4.namesAndTypes));
                } ; // TODO: add Function to symbol table with name, type, list_of_params.  Also add parameters (=list of names, types) to symbol table + function scope
RetType:		Type {$$ = RetType($1.type);} // DONE: extract type from Type
                    | VOID {$$ = RetType($1.type);}; //DONE: RetType.type = "VOID"
Formals:		/*epsilon*/ {} //DONE: nothing
                    | FormalsList {$$ = Formals($1.namesAndTypes);} ; // DONE: extract names, types from FormalsList.
FormalsList:	FormalDecl {$$ = FormalsList($1.name, $1.type);} // changed: adding a list to formalsList struct
                    | FormalDecl COMMA FormalsList{$$.addParamToFunc($1.name,$1.type);} ; //DONE: extract name, type from FormalDecl and append to list of names, types extracted from FormalsList
FormalDecl:		Type ID{FormalDecl($1.type, $2.name);} ;
Statements:		Statement {$$ = Statements($1.type);} //Done
                    | Statements Statement{} ; //nothing
Statement:		LBRACE {Framework::getInstance().addScope(Scope::BLOCK);} Statements
                         {Framework::getInstance().popScope();} RBRACE {} // Done
                    | Type ID SC { Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));} // Done
                    | Type ID ASSIGN Exp SC { Framework::getInstance().insertVariableIntoTopScope(Variable($2.name,$1.type));} // Done
                    | ID ASSIGN Exp SC {printf("------=-------");} //nothing
                    | Call SC {} //nothing
                    | RETURN SC {$$ = Statement("VOID");} // Done
                    | RETURN Exp SC {$$ = Statement($2.type);} // Done
                    | IF LPAREN Exp RPAREN Statement{
                        printf("-----------if-------------");
                        if ($3.type == "BOOL"){
                            Framework::getInstance().addScope(Scope::IF);
                        }
                        else{
                             output::errorMismatch(yylineno);
                             exit(0);
                        }

                    }
                    | IF LPAREN  Exp  RPAREN {Framework::getInstance().addScope(Scope::IF);}
                     Statement {Framework::getInstance().popScope();} ELSE {Framework::getInstance().addScope(Scope::IF);} Statement {Framework::getInstance().popScope();} {
                        if ($3.type != "BOOL"){
                            output::errorMismatch(yylineno);
                            exit(0);
                        }

                    }
                    | WHILE LPAREN Exp RPAREN {Framework::getInstance().addScope(Scope::LOOP);} Statement {Framework::getInstance().popScope();} {
                    if ($3.type != "BOOL"){
                         output::errorMismatch(yylineno);
                         exit(0);
                    }

                    }
                    | BREAK SC{
                        if(Framework::getInstance().getTopScope().getScopeType() != Scope::LOOP){
                             output::errorUnexpectedBreak(yylineno);
                             exit(0);
                    }
                     }
                    | CONTINUE SC{
                        if(Framework::getInstance().getTopScope().getScopeType() != Scope::LOOP){
                            output::errorUnexpectedContinue(yylineno);
                            exit(0);
                        }
                    }
Call:			ID LPAREN ExpList RPAREN {
                        //TODO: do not use symbol_table.operator[], instead use Framework.operator[].  And don't check if returned NULL, instead just catch IdentifierDoesNotExistException
                        try{
                            string type = Framework::getInstance()[$1.name].type; // check the syntax. need Framework::getInstance().symbol_table[$1.name] to be a "Function" struct
                            if(varsListToTypesList(dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters()) != $3.arrguments_list){
                                list<Variable> params = dynamic_cast<Function&>(Framework::getInstance()[$1.name]).getParameters();
                                const std::list<string> typesList = varsListToTypesList(params);
                                vector<string> argTypes = vector<string>(typesList.begin(), typesList.end());
                                output::errorPrototypeMismatch(yylineno, $1.name, argTypes);
                            }
                            $$ = Call ($1.name, type);
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            exit(0);
                        }


                    }
                    | ID LPAREN RPAREN {

                        try{
                               string type = Framework::getInstance()[$1.name].type;
                               $$ = Call ($1.name, type);
                        }
                        catch(Exceptions::IdentifierDoesNotExistException &e){
                            output::errorUndefFunc(yylineno, $1.name);
                            exit(0);
                        }
                    }; //
ExpList:		Exp {   $$ = ExpList(); // making the one size list by adding the EXP type into the list
                        $$.arrguments_list.push_back($1.type);

                     } //
                    | Exp COMMA ExpList { $$.arrguments_list.push_back($1.type);}// adding into the list
Type:			INT {$$ = Type("INT");}
                    | BYTE{$$ =  Type("BYTE");}
                    | BOOL {$$ =  Type("BOOL");}
                    | SET LBRACKET NUM DOTS NUM RBRACKET {$$ = Type("SET");};
Exp:			LPAREN Exp RPAREN {$$ =  Exp($2.type);} //
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1.type, $3.type);
                        $$ = Exp(res_type);
                        } //
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1.type, $3.type);
                        $$ = Exp(res_type);
                    }
                    | ID {
                            try{
                                $$ =  Exp(Framework::getInstance()[$1.name].type);
                            }
                            catch(Exceptions::IdentifierDoesNotExistException &e){
                                output::errorDef(yylineno, $1.name);
                                exit(0);
                            }


                      } //
                    | Call {$$ =  Exp($1.type);}
                    | NUM {$$ = Exp("INT");}
                    | NUM B {$$ =  Exp("BYTE");}
                    | STRING {$$ =  Exp("STRING");}
                    | TRUE {$$ =  Exp("BOOL");}
                    | FALSE {$$ =  Exp("BOOL");}
                    | NOT Exp {
                        if($2.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             exit(0);
                        }
                        else{
                            $$ =  Exp("BOOL");
                        }
                    }
                    | Exp AND Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             exit(0);
                       }
                       else{
                           $$ =  Exp("BOOL");
                       }
                    }
                    | Exp OR Exp{
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                             output::errorMismatch(yylineno);
                             exit(0);
                       }
                       else{
                           $$ =  Exp("BOOL");
                       }
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             exit(0);
                        }
                        else{
                            $$ =  Exp ("BOOL");
                        }
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                             output::errorMismatch(yylineno);
                             exit(0);
                      }
                      else{
                          $$ =  Exp ("BOOL");
                      }
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                             output::errorMismatch(yylineno);
                             exit(0);
                        }
                        else{
                            $$ =  Exp("INT");
                        }

                    };

%%
void yyerror(const char*){
	output::errorSyn(yylineno);
}

int main(){
    yyparse();
    if (!Framework::getInstance().mainExists) output::errorMainMissing();;
}