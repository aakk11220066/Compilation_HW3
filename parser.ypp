%{
	#include <iostream>
	#include <string>
	#include <stack>
	#include <list>
	using namespace std;
	#include "Framework.h"
	#include "Symbol.h"
	#include "Exceptions.h"

	class NonTerminal{
	public:
	    const string name = "";
	    const string type = "";
	    stack<NonTerminal> namesAndTypes = stack<NonTerminal>();

	    NonTerminal(const string& name, const string& type) : name(name), type(type) {}
	};

	//NonTerminal classes
    class Program : public NonTerminal{};
    class Funcs : public NonTerminal{};
    class FuncDecl : public NonTerminal{};
    class RetType : public NonTerminal{};
    class Formals : public NonTerminal{
    public:
        list<Variable> namesAndTypes;
        Formals(list<string> namesAndTypes) : namesAndTypes(namesAndTypes) {}
    };
    class FormalsList : public NonTerminal{
        public:
            list<NonTerminal> namesAndTypes;
            FormalsList(const string& name, const string& type) : NonTerminal("", "") {
                namesAndTypes.push_back(NonTerminal(name, type));
            }
            void addParamToFunc(const string& name,const string& type){
                this->namesAndTypes.push_back(NonTerminal(name, type));
            }
    };
	class FormalDecl : public NonTerminal{
	    FormalDecl(const string& name, const string& type) : NonTerminal(name, type) {}
	};
    class Statements : public NonTerminal{
        Statements(const string& type): NonTerminal("", type){}
    };
	class Statement : public NonTerminal{
	    public:
            bool is_break;
            bool is_continue;
            Statement(const string& type): NonTerminal("", type), is_break(false), is_continue(false){}
            Statement(const string& type, bool is_break, bool is_continue): NonTerminal("", type), is_break(is_break), is_continue(is_continue){}
	};
	class Call : public NonTerminal{};
	class ExpList : public NonTerminal{
	    public:
	    list<string> arrguments_list;
	    ExpList() : NonTerminal("", ""), arrguments_list(list<string>()) {}
	};
    class Type : public NonTerminal{
        Type(cont string& type) : type(type);
    };
    class Exp : public NonTerminal{
        Exp(cont string& type) : type(type);
    };

    static string typeBinopChecking(Exp e1, Exp e2){
        if (e1.type == "INT" || e2.type == "INT"){
            return "INT";
        }
        if(e1.type == "BYTE" || e2.type == "BYTE"){
            return "BYTE";
        }
        if(e1.type == "SET" && e2.type == "SET"){
            throw Exceptions::MismatchException(lineno);
        }
        return "SET";
    }

    string typeBinopMultiplicativeChecking(Exp e1, Exp e2){
        if(e1.type == "SET" || e2.type == "SET"){
            throw Exceptions::MismatchException(lineno);
        }
        if (e1.type == "INT" || e2.type == "INT"){
            return "INT";
        }
        return "BYTE";
    }

    extern list<string> varsListToTypesList(const list<Variable>& varList);

    //TODO: static function for the return issue
    extern int yylineno;
    extern YYSTYPE yylval;

    int yylex();
    void yyerror(const char*);
%}

%right ASSIGN
%left OR
%left AND
%left RELOP_EQUALITY
%nonassoc RELOP_RELATIONAL
%left BINOP_ADDITIVE
%left BINOP_MULTIPLICATIVE
%right NOT
%left SC RPAREN RBRACE RBRACKET
%right LBRACE LPAREN LBRACKET

%right COMMA WHILE ELSE IF
%nonassoc TRUE FALSE RETURN BREAK CONTINUE DOTS ID NUM STRING SET INT BYTE B BOOL VOID

%%


//TODO: ensure type safety on everything (a value can become it's own type.  A byte can become an int.) ("in" relop is used byte/int in set)
//DONE: errors
//DONE: print, printi
//TODO: complete Framework class
//TODO: Recursion problem - undefined at call time
//TODO: enforce size limitations on set and byte (255)
//DONE: enforce existence of void main() function


Program:		Funcs {};
Funcs:			/*epsilon*/ {} //DONE: nothing
                    |FuncDecl Funcs {}; //DONE: nothing
FuncDecl:		RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE{
                    Framework.getInstance().addFunction(Function($2.name,$1.type, $4.namesAndTypes));
                } ; // TODO: add Function to symbol table with name, type, list_of_params.  Also add parameters (=list of names, types) to symbol table + function scope
RetType:		Type {$$ = RetType($1.type);} // DONE: extract type from Type
                    | VOID {$$ = RetType($1.type);}; //DONE: RetType.type = "VOID"
Formals:		/*epsilon*/ {} //DONE: nothing
                    | FormalsList {$$ = Formals($1.namesAndTypes);} ; // DONE: extract names, types from FormalsList.
FormalsList:	FormalDecl {$$ = FormalsList($1.name, $1.type);} // changed: adding a list to formalsList struct
                    | FormalDecl COMMA FormalsList{$$.addParamToFunc($1.name,$1.type);} ; //DONE: extract name, type from FormalDecl and append to list of names, types extracted from FormalsList
FormalDecl:		Type ID{FormalDecl($1.type, $2.name);} ;
Statements:		Statement {$$ = Statements($1.type)} //Done
                    | Statements Statement{} ; //nothing
Statement:		LBRACE Statements RBRACE {Framework::getInstance().addScope(Framework::getInstance().scopeType.BLOCK);} // Done
                    | Type ID SC {insertVariableIntoTopScope(Variable($2,$1.type));} // Done
                    | Type ID ASSIGN Exp SC {insertVariableIntoTopScope(Variable($2,$1.type));} // Done
                    | ID ASSIGN Exp SC {} //nothing
                    | Call SC {} //nothing
                    | RETURN SC {$$ = new Statement("VOID");} // Done
                    | RETURN Exp SC {$$ = Statement($2.type)} // Done
                    | IF LPAREN Exp RPAREN Statement{
                        if ($3.type == "BOOL"){
                            Framework::getInstance().addScope(Framework::getInstance().scopeType.IF);
                        }
                        else{
                             throw Exceptions::MismatchException(lineno);
                        }

                    }
                    | IF LPAREN Exp RPAREN Statement ELSE Statement {
                        if ($3.type == "BOOL"){
                            Framework::getInstance().addScope(Framework::getInstance().scopeType.IF);
                            Framework::getInstance().addScope(Framework::getInstance().scopeType.IF);
                        }
                        else{
                             throw Exceptions::MismatchException(lineno);
                        }

                    }
                    | WHILE LPAREN Exp RPAREN Statement{
                    if ($3.type == "BOOL"){
                        Framework::getInstance().addScope(Framework::getInstance().scopeType.LOOP);
                    }
                    else{
                        throw Exceptions::MismatchException(lineno);
                    }

                    }
                    | BREAK SC{
                        if(Framework::getInstance().scopes.getTopScope().getType() != scopeType.LOOP){
                             throw Exceptions::UnexpectedBreakException(lineno);
                    }
                     }
                    | CONTINUE SC{
                        if(Framework::getInstance().scopes.getTopScope().getScopeType() != scopeType.LOOP){
                            throw Exceptions::UnexpectedContinueException(lineno);
                        }
                    }
Call:			ID LPAREN ExpList RPAREN {
                        if(!Framework::getInstance().contains($1.name)){
                            throw Exceptions::UndefFuncException(lineno,$1.name);
                        }
                        //TODO: do not use symbol_table.operator[], instead use Framework.operator[].  And don't check if returned NULL, instead just catch IdentifierDoesNotExistException
                        string type = Framework::getInstance().symbol_table[$1.name].type; // check the syntax. need Framework::getInstance().symbol_table[$1.name] to be a "Function" struct
                        if(!Framework::getInstance().symbol_table[$1.name].getList() == $3.getList()){
                            throw Exceptions::PrototypeMismatchException(lineno,$1.name,Framework::getInstance().symbol_table[$1.name].getParameters());
                        }
                        $$ = new Call ($1.name, type)
                        }
                    | ID LPAREN RPAREN {
                    if(!Framework::getInstance().contains($1.name)){
                       throw Exceptions::UndefFuncException(lineno,$1.name)
                       }
                       string type = Framework::getInstance().symbol_table[$1.name].type;
                       $$ = new Call ($1.name, type)
                    }; //
ExpList:		Exp {   $$ = new ExpList(); // making the one size list by adding the EXP type into the list
                        $$.addTypeToListArrguments($1.type);} //
                    | Exp COMMA ExpList { $$.addTypeToListArrguments($1.type)}; // adding into the list
Type:			INT {$$ = new Type("INT");}
                    | BYTE{$$ = new Type("BYTE");}
                    | BOOL {$$ = new Type("BOOL");}
                    | SET LBRACKET NUM DOTS NUM RBRACKET {$$ = new Type("SET");};
Exp:			LPAREN Exp RPAREN {$$ = new Exp($2.type);} //
                    | Exp BINOP_ADDITIVE Exp {
                        string res_type = typeBinopAddChecking($1,$2);
                        $$ = new Exp(res_type);
                        } //
                    | Exp BINOP_MULTIPLICATIVE Exp {
                        string res_type = typeBinopMultiplicativeChecking($1,$2);
                        $$ = new Exp(res_type);
                    }
                    | ID {$$ = new Exp(Framework::getInstance().symbol_table[$1.name].type);} //
                    | Call {$$ = new Exp($1.type);}
                    | NUM {$$ = new Exp("INT");}
                    | NUM B {$$ = new Exp("BYTE");}
                    | STRING {$$ = new Exp("STRING");}
                    | TRUE {$$ = new Exp("BOOL");}
                    | FALSE {$$ = new Exp("BOOL");}
                    | NOT Exp {
                        if($2.type != "BOOL"){
                            throw Exceptions::MismatchException(lineno);
                        }
                        else{
                            $$ = new Exp("BOOL");
                        }
                    }
                    | Exp AND Exp {
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                           throw Exceptions::MismatchException(lineno);
                       }
                       else{
                           $$ = new Exp("BOOL");
                       }
                    }
                    | Exp OR Exp{
                        if($1.type != "BOOL" || $3.type != "BOOL"){
                           throw Exceptions::MismatchException(lineno);
                       }
                       else{
                           $$ = new Exp("BOOL");
                       }
                    }
                    | Exp RELOP_RELATIONAL Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                            throw Exceptions::MismatchException(lineno);.
                        }
                        else{
                            $$ = new Exp ("BOOL");
                        }
                    }
                    | Exp RELOP_EQUALITY Exp {
                        if(($1.type != "INT" && $1.type != "BYTE") || ($2.type != "INT" && $2.type != "BYTE")){
                          throw Exceptions::MismatchException(lineno);
                      }
                      else{
                          $$ = new Exp ("BOOL");
                      }
                    }
                    | LPAREN Type RPAREN Exp {
                        if($2.type != "INT" || $4.type !="SET"){
                            throw Exceptions::MismatchException(lineno);
                        }
                        else{
                            $$ = new Exp("INT");
                        }

                    };

%%
void yyerror(const char*){
	output::errorSyn(yylineno);
}

int main(){
    try{
    	yyparse();
	    if (!Framework::getInstance().mainExists) throw Exceptions::NoMainException();
    }
    catch (Exceptions::HW3_Exception& e){
        e.printError();
    }
}